#!/usr/bin/env python3
import argparse
import gzip
import logging
import pysam
import re
import sys
from vase.ped_file import PedFile
from cnv_intersect.cnv_intersect import CnvIntersect
from cnv_intersect.cnv_vcf import CnvVcf, valid_cnv_types
from cnv_intersect.cnv_bed import CnvBed

cnv2alt = {'LOSS': '<DEL>',
           'GAIN': '<DUP>',
           'REF': None}
chrom_re = re.compile(r'^(chr)?(\\d+|[XY])$')


def get_argparser():
    parser = argparse.ArgumentParser(
        usage='%(prog)s [options] VCF VCF [VCF ...]',
        description='Generate VCF of overlapping CNVs from Canvas called VCF')
    parser.add_argument('vcfs', metavar='VCF', nargs='+',
                        help='2 or more input VCF files with CNV calls.')
    parser.add_argument('-p', '--ped', help='''PED file indicating which
                        individuals are affected. If not provided all
                        individuals in given VCFs are assumed to be
                        affected.''')
    parser.add_argument('-o', '--output', metavar='VCF/BCF output',
                        help='''Output file for intersected calls. Default is
                        STDOUT.''')
    parser.add_argument('-m', '--min_intersect', default=2, type=int,
                        metavar='N', help='''Minimum number of intersecting
                        VCFs required in order to output CNV. Default=2.''')
    parser.add_argument('-t', '--cnv_types', default=['LOSS', 'GAIN'],
                        nargs='+', help='''CNV types to identify. Valid values
                        are "LOSS" or "GAIN".''')
    parser.add_argument('--minimum_cnv_length', type=int, metavar='MIN',
                        help='''Set a minimum length cutoff. CNVs shorter than
                        this value will be ignored.''')
    parser.add_argument('--maximum_cnv_length', type=int, metavar='MAX',
                        help='''Set a maximum length cutoff. CNVs longer than
                        this value will be ignored.''')
    parser.add_argument('--pass_filters', action='store_true', help='''Ignore
                        CNVs without a PASS filter field.''')
    parser.add_argument('-f', '--filter_cnvs', metavar='BED', nargs='+',
                        help='''One or more BED files of CNVs to use as a
                        filter. CNV intersections will not be written if a CNV
                        in this file overlaps by a fraction equal to or greater
                        than the value specified by --overlap_fraction. CNV BED
                        files used here should either be generated by
                        downloading bigBeds from from UCSC (either dbVar or
                        DGV) and converting to bed using the bigBedToBed tool
                        from UCSC or should contain the CNV type ('GAIN' or
                        'LOSS') for each region as the fourth column.''')
    parser.add_argument('-x', '--overlap_fraction', type=float, default=0.8,
                        metavar='FRAC', help='''Minimum fraction overlap
                        of CNVs from --filter_cnvs file required in order to
                        filter an intersection region. Default=0.8.''')
    parser.add_argument('--debug', action='store_true', help=argparse.SUPPRESS)
    return parser


def get_logger(debug=False):
    level = logging.DEBUG if debug else logging.INFO
    logger = logging.getLogger("CNV Intersect")
    logger.setLevel(level)
    return logger


def get_contig_order(vcf):
    if vcf.index is not None:
        return dict(vcf.index)
    contigs = []
    prev_contig = None
    prev_pos = None
    not_sorted_err = ValueError("Input file '{}' is not sorted ".format(vcf) +
                                "- exiting!")
    for record in vcf:
        if record.chrom not in contigs:
            contigs.append(record.chrom)
        elif prev_contig is not None and record.chrom != prev_contig:
            raise not_sorted_err
        elif prev_pos is not None and prev_pos > record.pos:
            raise not_sorted_err
        prev_contig = record.chrom
        prev_pos = record.pos
    vcf.reset()
    return dict((k, n) for n, k in enumerate(contigs))


def check_contig_order(cnv_readers):
    contig_order = get_contig_order(cnv_readers[0].vcf)
    main_contig_order = dict((k, v) for k, v in contig_order.items() if
                             chrom_re.match(k))
    for cr in cnv_readers[1:]:
        co = get_contig_order(cr.vcf)
        main_co = dict((k, v) for k, v in co.items() if chrom_re.match(k))
        if main_co != main_contig_order:
            raise ValueError("Input VCFs do not share the same contig order!")
        for k in (x for x in co if x not in main_co and x not in contig_order):
            contig_order[k] = len(contig_order)
    return contig_order


def get_bed_filters(bed_files):
    bed_filters = []
    for bed in bed_files:
        if bed.endswith('.gz'):
            o_func = gzip.open
        else:
            o_func = open
        with o_func(bed, 'rt') as fh:
            for row in fh:
                if row.startswith('track name') or row.startswith('browser'):
                    continue
                break
        n_cols = len(row.split('\t'))
        if n_cols == 15:
            bed_format = 'dbVar'
        elif n_cols == 23:
            bed_format = 'DGV'
        else:
            bed_format = None
        bed_filters.append(CnvBed(bed, bed_format))
    return bed_filters


def get_out_handle(vcfs, output_name=None):
    if output_name is None:
        output_name = '-'
    vcf_temp = pysam.VariantFile(vcfs[0])
    out = pysam.VariantFile(output_name, mode='w', header=vcf_temp.header)
    #  add_order = ['name', 'number', 'type', 'description']
    out.header.formats.add(
        'IVST',
        1,
        'Integer',
        'Start coordinate of intersecting variant in this sample')
    out.header.formats.add(
        'IVED',
        1,
        'Integer',
        'End coordinate of intersecting variant in this sample')
    out.header.formats.add(
        'IVVC',
        1,
        'Integer',
        'Number of variant calls combined for this sample')
    out.header.formats.add(
        'MCN',
        1,
        'Float',
        'Mean copy number across intersected variants for this sample')
    out.header.formats.add(
        'LCN',
        1,
        'Integer',
        'Lowest copy number across intersected variants for this sample')
    out.header.formats.add(
        'HCN',
        1,
        'Integer',
        'Highest copy number across intersected variants for this sample')
    out.header.info.add(
        'IV5P',
        1,
        'Integer',
        'Start coordinate of 5\' most intersecting variant')
    out.header.info.add(
        'IV3P',
        1,
        'Integer',
        'End coordinate of 3\' most intersecting variant')
    out.header.info.add(
        'IVLEN',
        1,
        'Integer',
        'Length of variant intersection')
    vcf_temp.close()
    for v in vcfs[1:]:
        v_temp = pysam.VariantFile(v)
        for sample in v_temp.header.samples:
            out.header.samples.add(sample)
        v_temp.close()
    return out


def output_cnv(intersect, fh):
    rec = fh.new_record()
    rec.chrom = intersect.chrom
    rec.start = max(0, intersect.start)
    rec.stop = intersect.stop
    rec.ref = 'N'
    rec.alts = (cnv2alt[intersect.cnv_type],)
    rec.id = "CnvIS:{}:{}:{}-{}".format(intersect.cnv_type,
                                        intersect.chrom,
                                        intersect.start + 1,
                                        intersect.stop)
    rec.info['IV5P'] = intersect.limit_start + 1
    rec.info['IV3P'] = intersect.limit_stop
    rec.info['IVLEN'] = intersect.stop - intersect.start
    for samp_cnv in intersect.records:
        for s, d in samp_cnv.samples.items():
            rec.samples[s]['MCN'] = d['mean_copy_number']
            rec.samples[s]['LCN'] = d['min_copy_number']
            rec.samples[s]['HCN'] = d['max_copy_number']
            if 'BC' in fh.header.info:
                rec.samples[s]['BC'] = d['total_bin_counts']
            rec.samples[s]['IVVC'] = samp_cnv.n_records
            if s in samp_cnv.var_samples:
                rec.samples[s]['IVST'] = samp_cnv.start + 1
                rec.samples[s]['IVED'] = samp_cnv.stop
    fh.write(rec)


def main(vcfs, ped=None, output=None, cnv_types=['LOSS', 'GAIN'],
         pass_filters=False, min_intersect=2, filter_cnvs=None,
         overlap_fraction=0.8, minimum_cnv_length=None,
         maximum_cnv_length=None, debug=False):
    logger = get_logger(debug)
    pedfile = None
    invalid = set(cnv_types).difference(valid_cnv_types)
    if invalid:
        raise ValueError("ERROR: Invalid CNV types specified: {}".format(
            ", ".join(invalid)))
    if ped is not None:
        pedfile = PedFile(ped)
    filter_beds = None
    if filter_cnvs:
        filter_beds = get_bed_filters(filter_cnvs)
    outvcf = get_out_handle(vcfs, output)
    for cnv_type in cnv_types:
        cnv_readers = [CnvVcf(vcf=x,
                              cnv_type=cnv_type,
                              ped=pedfile,
                              pass_filters=pass_filters,
                              cnv_filters=filter_beds,
                              overlap_fraction=overlap_fraction,
                              minimum_length=minimum_cnv_length,
                              maximum_length=maximum_cnv_length) for x in vcfs]
        contig_order = check_contig_order(cnv_readers)
        cnvs = []
        prev_intersect = None
        for cr in cnv_readers:
            try:
                cnvs.append(next(cr))
            except StopIteration:
                logger.warning("No qualifying records in file {}".format(
                    cr.vcf.filename))
                cnvs.append(None)
        while True:
            if None in cnvs:
                remove = [i for i in range(len(cnvs)) if cnvs[i] is None]
                cnvs = [cnvs[i] for i in range(len(cnvs)) if i not in remove]
                cnv_readers = [cnv_readers[i] for i in range(len(cnv_readers))
                               if i not in remove]
                if len(cnvs) < min_intersect:
                    logger.info("Fewer than {} VCFs ".format(min_intersect) +
                                "with remaining {} calls. ".format(cnv_type) +
                                "Done parsing {} CNVs.".format(cnv_type))
                    break
            min_chrom = cnvs[0].chrom
            min_stop = cnvs[0].stop
            min_i = 0
            for i in range(1, len(cnvs)):
                if contig_order[cnvs[i].chrom] < contig_order[min_chrom]:
                    min_chrom = cnvs[i].chrom
                    min_stop = cnvs[i].stop
                    min_i = i
                elif cnvs[i].chrom == min_chrom and cnvs[i].stop < min_stop:
                    min_stop = cnvs[i].stop
                    min_i = i
            others = (cnvs[i] for i in range(len(cnvs)) if i != min_i)
            overlaps = [x for x in others if x.overlaps(cnvs[min_i])]
            if overlaps:
                overlaps.append(cnvs[min_i])
                if len(overlaps) >= min_intersect:
                    intersect = CnvIntersect(cnvs=overlaps)
                    logger.debug("Overlapping {} at {}:{}-{} ({})".format(
                        intersect.cnv_type,
                        intersect.chrom,
                        intersect.start,
                        intersect.stop,
                        intersect.n_cnvs))
                    # only output if not contained in prev written intersect
                    no_overlap = False
                    if prev_intersect is None:
                        no_overlap = True
                    else:
                        prev_recs = set(hash(x) for x in
                                        prev_intersect.records)
                        curr_recs = set((hash(x) for x in intersect.records))
                        if not prev_recs.issuperset(curr_recs):
                            no_overlap = True
                    if no_overlap:
                        output_cnv(intersect, outvcf)
                        prev_intersect = intersect
            for i in (x for x in range(len(cnvs)) if cnvs[x].stop == min_stop):
                try:
                    cnvs[i] = next(cnv_readers[i])
                except StopIteration:
                    logger.info("Finished reading {}".format(vcfs[i]))
                    logger.info("{:,} records read, ".format(
                                    cnv_readers[i].records_read) +
                                "{:,} filtered, ".format(
                                    cnv_readers[i].records_filtered) +
                                "{:,} CNVs aggregated".format(
                                    cnv_readers[i].cnvs_created))
                    cnvs[i] = None
    outvcf.close()


if __name__ == '__main__':
    parser = get_argparser()
    args = parser.parse_args()
    if len(args.vcfs) < 2:
        parser.print_usage()
        sys.exit('At least 2 VCFs must be provided.')
    main(**vars(args))
